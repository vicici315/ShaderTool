import wx
import os
import json
import sys


class HelpDialog(wx.Dialog):
    """帮助对话框，显示Snipaste_help.png图片（使用Base64编码）"""
    def __init__(self, parent):
        super().__init__(parent, title="帮助", size=(500, 600))
        
        # 设置对话框样式
        self.SetExtraStyle(wx.DIALOG_EX_CONTEXTHELP)
        
        # 创建面板
        panel = wx.Panel(self)
        
        # 创建垂直布局
        vbox = wx.BoxSizer(wx.VERTICAL)
        
        # 加载并显示图片（从Base64）
        try:
            # Base64编码的图片数据
            # 请将您的Base64图片数据粘贴在下面的字符串中
            # 格式：以"data:image/png;base64,"开头，后面是Base64编码的图片数据
            image_base64 = """
            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
            """
            
            # 清理Base64字符串（移除注释和空白字符）
            import re
            # 提取实际的Base64数据（可能包含data:image/png;base64,前缀）
            base64_match = re.search(r'base64,(.*)', image_base64, re.DOTALL)
            if base64_match:
                base64_data = base64_match.group(1).strip()
            else:
                # 如果没有前缀，直接使用整个字符串
                base64_data = image_base64.strip()
            
            # 移除所有空白字符（换行、空格等）
            base64_data = re.sub(r'\s', '', base64_data)
            
            if base64_data and len(base64_data) > 100:  # 简单的有效性检查
                # 导入base64模块
                import base64
                
                # 解码Base64数据
                image_data = base64.b64decode(base64_data)
                
                # 创建内存流
                import io
                stream = io.BytesIO(image_data)
                
                # 从内存流加载图片
                image = wx.Image(stream, wx.BITMAP_TYPE_ANY)
                
                if image.IsOk():
                    # 直接使用原始图片，不进行缩放
                    bitmap = wx.Bitmap(image)
                    
                    # 创建静态位图控件
                    static_bitmap = wx.StaticBitmap(panel, bitmap=bitmap)
                    vbox.Add(static_bitmap, flag=wx.ALIGN_CENTER | wx.ALL, border=10)
                    
                    # 添加帮助文本
                    help_text = "Shader 在 Unity 中编译输出设置选项如上图"
                    help_label = wx.StaticText(panel, label=help_text)
                    help_label.SetFont(wx.Font(11, wx.FONTFAMILY_DEFAULT, wx.FONTSTYLE_NORMAL, wx.FONTWEIGHT_BOLD))
                    help_label.SetForegroundColour(wx.Colour(0, 100, 200))  # 蓝色
                    vbox.Add(help_label, flag=wx.ALIGN_CENTER | wx.BOTTOM, border=10)
                else:
                    # 图片加载失败
                    error_label = wx.StaticText(panel, label="错误: Base64图片数据无效")
                    error_label.SetForegroundColour(wx.Colour(255, 0, 0))
                    vbox.Add(error_label, flag=wx.ALIGN_CENTER | wx.ALL, border=20)
            else:
                # Base64数据为空或太短
                error_label = wx.StaticText(panel, label="错误: 未提供有效的Base64图片数据")
                error_label.SetForegroundColour(wx.Colour(255, 0, 0))
                vbox.Add(error_label, flag=wx.ALIGN_CENTER | wx.ALL, border=20)
        except Exception as e:
            # 图片加载失败时显示错误信息
            error_label = wx.StaticText(panel, label=f"加载Base64图片失败: {str(e)}")
            error_label.SetForegroundColour(wx.Colour(255, 0, 0))
            vbox.Add(error_label, flag=wx.ALIGN_CENTER | wx.ALL, border=20)
        
        # 添加可伸缩的空间，将按钮推到底部
        vbox.AddStretchSpacer()
        
        # 添加关闭按钮在底部
        close_btn = wx.Button(panel, label="关闭帮助 (ESC)")
        close_btn.Bind(wx.EVT_BUTTON, self.on_close)
        close_btn.SetBackgroundColour(wx.Colour(245, 95, 90))
        vbox.Add(close_btn, flag=wx.ALIGN_CENTER | wx.ALL, border=10)
        
        # 设置面板布局
        panel.SetSizer(vbox)
        
        # 绑定ESC键关闭对话框
        self.Bind(wx.EVT_CHAR_HOOK, self.on_key_press)
        
        # 绑定关闭事件
        self.Bind(wx.EVT_CLOSE, self.on_close)
        
        # 居中显示
        self.Centre()
    
    def on_key_press(self, event):
        """处理键盘事件：ESC键关闭对话框"""
        keycode = event.GetKeyCode()
        
        # ESC键关闭对话框
        if keycode == wx.WXK_ESCAPE:
            self.Close()
            return
        
        event.Skip()
    
    def on_close(self, event):
        """处理关闭事件"""
        self.Destroy()


class CompileResultDialog(wx.Dialog):
    """编译结果对话框（非模态）"""
    def __init__(self, parent, frag_file_name, output):
        super().__init__(parent, title=f"编译结果 - {frag_file_name}", size=(800, 550))
        
        # 设置对话框样式，允许同时打开多个
        self.SetExtraStyle(wx.DIALOG_EX_CONTEXTHELP)
        
        # 创建控件
        text_ctrl = wx.TextCtrl(self, value=output, 
                               style=wx.TE_MULTILINE | wx.TE_READONLY | wx.TE_WORDWRAP | wx.TE_RICH2)
        # 设置浅灰色背景
        text_ctrl.SetBackgroundColour(wx.Colour(200, 200, 200))
        # 使用与PowerShell相同的字体，确保显示一致性
        try:
            # PowerShell常用字体优先级：Lucida Console -> Consolas -> 系统等宽字体
            font_names = ["Cascadia Mono", "Consolas", "Courier New"]
            # font_names = ["Lucida Console", "Consolas", "Courier New"]
            selected_font = None
            
            for font_name in font_names:
                try:
                    font = wx.Font(10, wx.FONTFAMILY_DEFAULT, wx.FONTSTYLE_NORMAL,
                                  wx.FONTWEIGHT_NORMAL, faceName=font_name)
                    if font.IsOk():
                        selected_font = font
                        break
                except:
                    continue
            
            if selected_font:
                text_ctrl.SetFont(selected_font)
            else:
                # 所有指定字体都不可用时使用系统等宽字体
                text_ctrl.SetFont(wx.Font(10, wx.FONTFAMILY_MODERN, wx.FONTSTYLE_NORMAL, wx.FONTWEIGHT_NORMAL))
        except:
            # 异常情况下使用系统等宽字体
            text_ctrl.SetFont(wx.Font(10, wx.FONTFAMILY_MODERN, wx.FONTSTYLE_NORMAL, wx.FONTWEIGHT_NORMAL))
        
        # 添加关闭按钮
        self.close_btn = wx.Button(self, label="关闭")
        self.close_btn.Bind(wx.EVT_BUTTON, self.on_close)
        self.close_btn.SetBackgroundColour(wx.Colour(245, 95, 90))
        
        # 添加复制按钮
        copy_btn = wx.Button(self, label="复制结果")
        copy_btn.Bind(wx.EVT_BUTTON, lambda e: self.copy_to_clipboard(output))
        copy_btn.SetBackgroundColour(wx.Colour(155, 225, 110))
        
        # 计算Longest Path Cycles三个值的和
        cycles_sum = self.calculate_longest_path_cycles_sum(output)
        
        # 创建结果显示文本
        result_text = ""
        if cycles_sum is not None:
            # 检查是否为整数：如果cycles_sum与它的整数部分相等，则为整数
            if cycles_sum.is_integer():
                result_text = f"LongestPathCycles总和: {int(cycles_sum)}"
            else:
                result_text = f"LongestPathCycles总和: {cycles_sum}"
        else:
            result_text = "LongestPathCycles: --"
        
        result_label = wx.StaticText(self, label=result_text)
        
        # 根据总和结果分级设置字体颜色
        if cycles_sum is not None:
            if cycles_sum <= 40:
                # 40以下：绿色 - 良好性能
                result_label.SetForegroundColour(wx.Colour(0, 180, 0))  # 绿色
            elif cycles_sum <= 79:
                # 41~79：橙色 - 中等性能
                result_label.SetForegroundColour(wx.Colour(255, 140, 0))  # 橙色
            else:
                # 80以上：红色 - 需要优化
                result_label.SetForegroundColour(wx.Colour(220, 0, 0))  # 红色
        else:
            # 无数据：蓝色
            result_label.SetForegroundColour(wx.Colour(0, 100, 200))  # 蓝色
        
        result_label.SetFont(wx.Font(12, wx.FONTFAMILY_DEFAULT, wx.FONTSTYLE_NORMAL, wx.FONTWEIGHT_BOLD))
        
        # 布局
        sizer = wx.BoxSizer(wx.VERTICAL)
        sizer.Add(text_ctrl, proportion=1, flag=wx.EXPAND | wx.ALL, border=10)
        
        # 底部按钮和结果区域
        bottom_sizer = wx.BoxSizer(wx.HORIZONTAL)
        
        # 左侧：结果文本
        bottom_sizer.Add(result_label, proportion=1, flag=wx.ALIGN_CENTER_VERTICAL | wx.LEFT, border=10)
        
        # 右侧：按钮
        btn_sizer = wx.BoxSizer(wx.HORIZONTAL)
        btn_sizer.Add(copy_btn, flag=wx.ALIGN_CENTER | wx.RIGHT, border=10)
        btn_sizer.Add(self.close_btn, flag=wx.ALIGN_CENTER)
        bottom_sizer.Add(btn_sizer, flag=wx.ALIGN_CENTER | wx.RIGHT, border=10)
        
        sizer.Add(bottom_sizer, flag=wx.EXPAND | wx.LEFT | wx.RIGHT | wx.BOTTOM, border=10)
        self.SetSizer(sizer)
        
        # 居中显示
        self.Centre()
        
        # 绑定关闭事件
        self.Bind(wx.EVT_CLOSE, self.on_close)
        
        # 设置默认按钮为关闭按钮
        self.close_btn.SetDefault()
        
        # 在对话框显示后将焦点设置到关闭按钮
        self.Bind(wx.EVT_SHOW, self.on_show)
    
    def calculate_longest_path_cycles_sum(self, output):
        """计算Longest Path Cycles三个值的和"""
        try:
            # 查找"Longest Path Cycles:"在文本中的位置
            lines = output.split('\n')
            for line in lines:
                if "Longest Path Cycles:" in line:
                    # 提取冒号后面的部分
                    parts = line.split("Longest Path Cycles:")
                    if len(parts) > 1:
                        values_str = parts[1].strip()
                        
                        # 提取所有数字（可能用逗号、空格分隔，包括小数）
                        import re
                        # 匹配整数和小数，例如：1.7, 2, 0.5, 3.14
                        numbers = re.findall(r'\d+\.?\d*', values_str)
                        
                        if len(numbers) >= 3:
                            # 取前三个数字
                            try:
                                num1 = float(numbers[0])
                                num2 = float(numbers[1])
                                num3 = float(numbers[2])
                                return num1 + num2 + num3
                            except ValueError:
                                return None
            return None
        except Exception as e:
            print(f"计算Longest Path Cycles总和时出错: {e}")
            return None
    
    def on_show(self, event):
        """处理对话框显示事件：将焦点设置到关闭按钮"""
        if event.IsShown():
            # 延迟设置焦点，确保对话框完全显示
            wx.CallAfter(self.close_btn.SetFocus)
        event.Skip()
    
    def on_close(self, event):
        """处理关闭事件"""
        self.Destroy()
    
    @staticmethod
    def copy_to_clipboard(text):
        """复制文本到剪贴板"""
        if wx.TheClipboard.Open():
            wx.TheClipboard.SetData(wx.TextDataObject(text))
            wx.TheClipboard.Close()
            # wx.MessageBox("结果已复制到剪贴板", "提示", wx.OK | wx.ICON_INFORMATION)


class ShaderBrowser(wx.Frame):
    # 版本号定义，方便更新
    VERSION = "1.4"
    CONFIG_FILE = "shader_browser_config.json"
    
    def __init__(self, parent, title):
        # 在标题中添加版本号
        full_title = f"{title} v{self.VERSION}"
        super(ShaderBrowser, self).__init__(parent, title=full_title, size=(800, 700))

        # 设置窗口图标
        self.SetIcon(self.load_icon())
        
        self.InitUI()
        self.Centre()
        self.Show()
        
        # 加载保存的路径
        self.load_saved_path()
        
        # 绑定F1键显示帮助
        self.Bind(wx.EVT_CHAR_HOOK, self.on_key_press)
        
        # 帮助窗口引用，用于限制只能打开一个帮助窗口
        self.help_dialog = None
    
    def load_icon(self):
        """加载窗口图标"""
        try:
            # 尝试加载mm1.ico文件
            icon_path = "mm1.ico"
            if os.path.exists(icon_path):
                icon = wx.Icon(icon_path, wx.BITMAP_TYPE_ICO)
                if icon.IsOk():
                    return icon
            
            # 如果文件不存在或加载失败，创建默认图标
            return self.create_default_icon()
        except Exception as e:
            print(f"加载图标失败: {e}")
            return self.create_default_icon()
    
    def create_default_icon(self):
        """创建默认图标"""
        try:
            # 创建一个简单的默认图标（16x16和32x32）
            icon = wx.Icon()
            
            # 创建16x16位图
            bmp16 = wx.Bitmap(16, 16)
            dc = wx.MemoryDC(bmp16)
            dc.SetBackground(wx.Brush(wx.Colour(0, 120, 215)))  # 蓝色背景
            dc.Clear()
            dc.SetTextForeground(wx.Colour(255, 255, 255))  # 白色文字
            dc.SetFont(wx.Font(8, wx.FONTFAMILY_DEFAULT, wx.FONTSTYLE_NORMAL, wx.FONTWEIGHT_BOLD))
            dc.DrawText("S", 4, 2)  # 绘制"S"表示Shader
            dc.SelectObject(wx.NullBitmap)
            
            # 创建32x32位图  
            bmp32 = wx.Bitmap(32, 32)
            dc = wx.MemoryDC(bmp32)
            dc.SetBackground(wx.Brush(wx.Colour(0, 120, 215)))  # 蓝色背景
            dc.Clear()
            dc.SetTextForeground(wx.Colour(255, 255, 255))  # 白色文字
            dc.SetFont(wx.Font(14, wx.FONTFAMILY_DEFAULT, wx.FONTSTYLE_NORMAL, wx.FONTWEIGHT_BOLD))
            dc.DrawText("S", 10, 6)  # 绘制"S"表示Shader
            dc.SelectObject(wx.NullBitmap)
            
            # 将16x16位图复制到图标
            icon.CopyFromBitmap(bmp16)
            return icon
        except:
            # 如果创建默认图标也失败，返回空图标
            return wx.Icon()
    
    def InitUI(self):
        panel = wx.Panel(self)
        
        # 创建垂直布局管理器
        vbox = wx.BoxSizer(wx.VERTICAL)
        
        # 第一行：路径标签和输入框
        hbox1 = wx.BoxSizer(wx.HORIZONTAL)

        self.browse_btn = wx.Button(panel, label="浏览路径:", size=(68, -1))
        self.browse_btn.Bind(wx.EVT_BUTTON, self.on_browse)
        # 设置橙黄色背景
        self.browse_btn.SetBackgroundColour(wx.Colour(255, 225, 110))  # 橙黄色
        hbox1.Add(self.browse_btn, flag=wx.EXPAND)
        self.path_combo = wx.ComboBox(panel, style=wx.CB_DROPDOWN | wx.TE_PROCESS_ENTER)
        self.path_combo.Bind(wx.EVT_TEXT_ENTER, self.on_path_enter)
        self.path_combo.Bind(wx.EVT_COMBOBOX, self.on_path_combo_select)
        # 设置浅黄色背景
        self.path_combo.SetBackgroundColour(wx.Colour(255, 255, 224))  # 浅黄色
        hbox1.Add(self.path_combo, proportion=1, flag=wx.EXPAND)
        
        # 添加清空历史按钮到路径输入框右边
        self.clear_history_btn = wx.Button(panel, label="清空历史")
        self.clear_history_btn.Bind(wx.EVT_BUTTON, self.on_clear_history)
        # 设置浅红色背景
        self.clear_history_btn.SetBackgroundColour(wx.Colour(255, 182, 193))  # 浅红色
        hbox1.Add(self.clear_history_btn, flag=wx.ALIGN_CENTER | wx.LEFT, border=10)

        vbox.Add(hbox1, flag=wx.EXPAND | wx.LEFT | wx.RIGHT | wx.TOP, border=10)

        # 第二行：操作按钮
        hbox2 = wx.BoxSizer(wx.HORIZONTAL)

        self.workFrag_btn = wx.Button(panel, label="分离frag")
        self.workFrag_btn.Bind(wx.EVT_BUTTON, self.on_separate_frag)
        # 设置浅蓝色背景
        self.workFrag_btn.SetBackgroundColour(wx.Colour(173, 216, 230))  # 浅蓝色
        hbox2.Add(self.workFrag_btn, flag=wx.ALIGN_CENTER | wx.LEFT, border=10)
        
        self.refresh_btn = wx.Button(panel, label="刷新")
        self.refresh_btn.Bind(wx.EVT_BUTTON, self.on_refresh)
        # 设置绿色背景
        self.refresh_btn.SetBackgroundColour(wx.Colour(144, 238, 144))  # 浅绿色
        hbox2.Add(self.refresh_btn, flag=wx.ALIGN_CENTER | wx.LEFT, border=10)
        
        # 添加可伸缩的空间，使后面的按钮靠右对齐
        hbox2.AddStretchSpacer()
        
        self.openFrag_btn = wx.Button(panel, label="打开frag变体")
        self.openFrag_btn.Bind(wx.EVT_BUTTON, self.on_open_frag)
        self.openFrag_btn.SetBackgroundColour(wx.Colour(164, 188, 250))  # 浅绿色
        hbox2.Add(self.openFrag_btn, flag=wx.ALIGN_CENTER | wx.RIGHT, border=10)
        
        vbox.Add(hbox2, flag=wx.EXPAND | wx.TOP, border=10)
        
        # 第三行：双列表标签行
        hbox_labels = wx.BoxSizer(wx.HORIZONTAL)
        
        file_label = wx.StaticText(panel, label="shader 文件列表:")
        hbox_labels.Add(file_label, proportion=1, flag=wx.EXPAND)
        
        # frag标签和总和显示区域
        frag_label_sizer = wx.BoxSizer(wx.HORIZONTAL)
        frag_label = wx.StaticText(panel, label="frag 列表:")
        frag_label_sizer.Add(frag_label, flag=wx.ALIGN_CENTER_VERTICAL)
        
        # 添加复杂度显示文本（初始为空）
        self.frag_sum_label = wx.StaticText(panel, label="")
        self.frag_sum_label.SetFont(wx.Font(10, wx.FONTFAMILY_DEFAULT, wx.FONTSTYLE_NORMAL, wx.FONTWEIGHT_BOLD))
        self.frag_sum_label.SetMinSize((100, -1))  # 设置最小宽度
        frag_label_sizer.Add(self.frag_sum_label, flag=wx.ALIGN_CENTER_VERTICAL | wx.LEFT, border=10)
        
        # 添加指令数显示文本（初始为空）
        self.instructions_label = wx.StaticText(panel, label="")
        self.instructions_label.SetFont(wx.Font(10, wx.FONTFAMILY_DEFAULT, wx.FONTSTYLE_NORMAL, wx.FONTWEIGHT_BOLD))
        self.instructions_label.SetMinSize((100, -1))  # 设置最小宽度
        frag_label_sizer.Add(self.instructions_label, flag=wx.ALIGN_CENTER_VERTICAL | wx.LEFT, border=10)
        
        hbox_labels.Add(frag_label_sizer, proportion=1, flag=wx.EXPAND)
        
        vbox.Add(hbox_labels, flag=wx.EXPAND | wx.LEFT | wx.RIGHT | wx.TOP, border=10)
        
        # 第四行：双列表框
        hbox_lists = wx.BoxSizer(wx.HORIZONTAL)

        # 左侧：文件列表框
        self.file_list = wx.ListBox(panel, style=wx.LB_SINGLE | wx.LB_HSCROLL)
        self.file_list.Bind(wx.EVT_LISTBOX_DCLICK, self.on_file_double_click)
        self.file_list.SetMinSize((0, -1))  # 👈 关键：允许水平方向被压缩
        hbox_lists.Add(self.file_list, proportion=1, flag=wx.EXPAND)

        # 右侧：frag 列表框（与左侧列表之间添加10像素间距）
        self.frag_list = wx.ListBox(panel, style=wx.LB_SINGLE | wx.LB_HSCROLL)
        self.frag_list.Bind(wx.EVT_LISTBOX_DCLICK, self.on_frag_double_click)
        self.frag_list.Bind(wx.EVT_LISTBOX, self.on_frag_click)
        self.frag_list.Bind(wx.EVT_CHAR_HOOK, self.on_frag_char_hook)
        self.frag_list.SetMinSize((0, -1))  # 👈 同样设置
        hbox_lists.Add(self.frag_list, proportion=1, flag=wx.EXPAND | wx.LEFT, border=6)
        
        vbox.Add(hbox_lists, proportion=1, flag=wx.EXPAND | wx.LEFT | wx.RIGHT | wx.TOP, border=10)
        
        # 第五行：状态栏
        self.status_bar = wx.StatusBar(panel)
        vbox.Add(self.status_bar, flag=wx.EXPAND | wx.LEFT | wx.RIGHT | wx.BOTTOM, border=10)
        
        panel.SetSizer(vbox)
    
    def on_file_double_click(self, event):
        """处理文件列表双击事件"""
        selection = self.file_list.GetSelection()
        if selection != wx.NOT_FOUND:
            file_name = self.file_list.GetString(selection)
            current_path = self.path_combo.GetValue()
            if current_path:
                full_path = os.path.join(current_path, file_name)
                wx.MessageBox(f"完整路径:\n{full_path}", "文件信息", wx.OK | wx.ICON_INFORMATION)
    
    def on_path_enter(self, event):
        """处理路径组合框回车事件"""
        path = self.path_combo.GetValue()
        if path:
            self.load_shader_files(path)
    
    def on_path_combo_select(self, event):
        """处理路径组合框选择事件"""
        # 获取选择的索引
        selection = event.GetSelection()
        if selection != wx.NOT_FOUND:
            # 从ComboBox获取选择的字符串
            path = self.path_combo.GetString(selection)
            if path:
                # 使用CallAfter确保在事件处理完成后更新UI
                wx.CallAfter(self._handle_path_selection, path)
    
    def _handle_path_selection(self, path):
        """处理路径选择（在事件处理完成后调用）"""
        # 更新ComboBox的值
        self.path_combo.SetValue(path)
        # 然后加载文件
        self.load_shader_files(path)
    
    def on_browse(self, event):
        """处理浏览按钮点击事件"""
        dlg = wx.DirDialog(self, "选择包含 .shader 文件的目录", 
                          style=wx.DD_DEFAULT_STYLE | wx.DD_DIR_MUST_EXIST)
        
        if dlg.ShowModal() == wx.ID_OK:
            selected_path = dlg.GetPath()
            self.path_combo.SetValue(selected_path)
            self.load_shader_files(selected_path)
        
        dlg.Destroy()
    
    def save_path_to_config(self, path):
        """保存路径到配置文件（添加到历史记录）并更新ComboBox"""
        try:
            # 检查路径是否有效（是否是有效的目录）
            if not path or not os.path.isdir(path):
                self.status_bar.SetStatusText(f"无效路径，不保存到历史记录: {path}")
                return
            
            # 读取现有配置
            config = {}
            if os.path.exists(self.CONFIG_FILE):
                with open(self.CONFIG_FILE, 'r', encoding='utf-8') as f:
                    config = json.load(f)
            
            # 获取或初始化历史记录
            path_history = config.get("path_history", [])
            
            # 如果路径不在历史记录中，添加到开头
            if path not in path_history:
                path_history.insert(0, path)
                # 限制历史记录数量（例如最多20个）
                if len(path_history) > 20:
                    path_history = path_history[:20]
            
            # 更新配置
            config["path_history"] = path_history
            config["last_path"] = path  # 保持向后兼容
            
            with open(self.CONFIG_FILE, 'w', encoding='utf-8') as f:
                json.dump(config, f, indent=2, ensure_ascii=False)
            
            # 使用Freeze/Thaw防止UI闪烁
            self.path_combo.Freeze()
            
            # 保存当前ComboBox的值和选择
            current_value = self.path_combo.GetValue()
            current_selection = self.path_combo.GetSelection()
            
            # 更新ComboBox的下拉列表
            self.path_combo.SetItems(path_history)
            
            # 恢复值
            self.path_combo.SetValue(path)
            
            self.path_combo.Thaw()
            
            self.status_bar.SetStatusText(f"路径已保存到历史记录: {self.CONFIG_FILE}")
        except Exception as e:
            self.status_bar.SetStatusText(f"保存配置文件失败: {str(e)}")
    
    def load_saved_path(self):
        """从配置文件加载保存的路径和历史记录，如果没有则使用当前目录"""
        try:
            current_dir = os.getcwd()  # 获取当前工作目录
            
            if os.path.exists(self.CONFIG_FILE):
                with open(self.CONFIG_FILE, 'r', encoding='utf-8') as f:
                    config = json.load(f)
                    
                    # 加载历史记录
                    path_history = config.get("path_history", [])
                    if path_history:
                        self.path_combo.SetItems(path_history)
                    
                    # 加载最后使用的路径
                    last_path = config.get("last_path", "")
                    if last_path and os.path.isdir(last_path):
                        # 使用保存的路径
                        self.path_combo.SetValue(last_path)
                        self.load_shader_files(last_path)
                        self.status_bar.SetStatusText(f"已加载路径: {last_path}")
                        return
                    else:
                        self.status_bar.SetStatusText("配置文件中没有有效的路径，使用当前目录")
            else:
                self.status_bar.SetStatusText("配置文件不存在，使用当前目录")
            
            # 使用当前目录
            self.path_combo.SetValue(current_dir)
            self.load_shader_files(current_dir)
            self.status_bar.SetStatusText(f"已加载当前目录: {current_dir}")
            
        except Exception as e:
            self.status_bar.SetStatusText(f"加载路径失败: {str(e)}")
            # 失败时也尝试加载当前目录
            try:
                current_dir = os.getcwd()
                self.path_combo.SetValue(current_dir)
                self.load_shader_files(current_dir)
            except:
                pass
    
    def on_frag_click(self, event):
        """处理frag列表单击事件：计算并显示Longest Path Cycles总和"""
        selection = self.frag_list.GetSelection()
        if selection == wx.NOT_FOUND:
            # 清空显示
            self.frag_sum_label.SetLabel("")
            self.instructions_label.SetLabel("")
            return
        
        frag_file_name = self.frag_list.GetString(selection)
        current_path = self.path_combo.GetValue()
        if not current_path:
            self.frag_sum_label.SetLabel("请先选择路径")
            self.frag_sum_label.SetForegroundColour(wx.Colour(0, 100, 200))  # 蓝色
            self.instructions_label.SetLabel("")
            return
        
        # 构建frag文件的完整路径
        frags_dir = os.path.join(current_path, "Frags")
        frag_file_path = os.path.join(frags_dir, frag_file_name)
        
        if not os.path.exists(frag_file_path):
            self.frag_sum_label.SetLabel("文件不存在")
            self.frag_sum_label.SetForegroundColour(wx.Colour(0, 100, 200))  # 蓝色
            self.instructions_label.SetLabel("")
            return
        
        # 查找malisc.exe
        malisc_path = self.find_malisc_exe()
        if not malisc_path:
            self.frag_sum_label.SetLabel("未找到malisc.exe")
            self.frag_sum_label.SetForegroundColour(wx.Colour(0, 100, 200))  # 蓝色
            self.instructions_label.SetLabel("")
            return
        
        # 在新线程中执行编译并计算总和
        import threading
        thread = threading.Thread(
            target=self.calculate_frag_cycles_sum_in_thread,
            args=(frag_file_name, frag_file_path, malisc_path)
        )
        thread.daemon = True
        thread.start()
        
        # 显示加载中状态
        self.frag_sum_label.SetLabel(f"{frag_file_name}")
        self.frag_sum_label.SetForegroundColour(wx.Colour(0, 100, 200))  # 蓝色
    
    def calculate_frag_cycles_sum_in_thread(self, frag_file_name, frag_file_path, malisc_path):
        """在新线程中编译frag文件并计算Longest Path Cycles总和和指令数"""
        try:
            # 使用powershell执行malisc.exe
            cmd = f'powershell -Command "& \'{malisc_path}\' \'{frag_file_path}\'"'
            
            # 执行命令
            import subprocess
            result = subprocess.run(cmd, shell=True, capture_output=True, text=True, encoding='utf-8')
            
            # 获取输出
            output = result.stdout
            if result.returncode != 0:
                output += f"\n\n错误代码: {result.returncode}"
                if result.stderr:
                    output += f"\n错误信息: {result.stderr}"
            
            # 计算Longest Path Cycles总和
            cycles_sum = self.calculate_longest_path_cycles_sum(output)
            
            # 提取Instructions Emitted值
            instructions = self.extract_instructions_emitted(output)
            
            # 在主线程中更新显示
            wx.CallAfter(self.update_frag_sum_display, frag_file_name, cycles_sum, instructions)
            
        except Exception as e:
            error_msg = f"计算失败: {str(e)}"
            wx.CallAfter(self.update_frag_sum_display, frag_file_name, None, None, error_msg)
    
    def update_frag_sum_display(self, frag_file_name, cycles_sum, instructions=None, error_msg=None):
        """更新frag总和显示和指令数显示"""
        if error_msg:
            # 显示错误信息
            self.frag_sum_label.SetLabel(f"错误: {error_msg[:30]}...")
            self.frag_sum_label.SetForegroundColour(wx.Colour(0, 100, 200))  # 蓝色
            self.instructions_label.SetLabel("")
            return
        
        # 更新复杂度显示
        if cycles_sum is not None:
            # 检查是否为整数：如果cycles_sum与它的整数部分相等，则为整数
            if cycles_sum.is_integer():
                display_text = f"复杂度:{int(cycles_sum)}"
            else:
                display_text = f"复杂度:{cycles_sum}"
            
            # 根据总和设置颜色（与CompileResultDialog一致）
            if cycles_sum <= 40:
                # 40以下：绿色 - 良好性能
                self.frag_sum_label.SetForegroundColour(wx.Colour(0, 180, 0))  # 绿色
            elif cycles_sum <= 79:
                # 41~79：橙色 - 中等性能
                self.frag_sum_label.SetForegroundColour(wx.Colour(255, 140, 0))  # 橙色
            else:
                # 80以上：红色 - 需要优化
                self.frag_sum_label.SetForegroundColour(wx.Colour(220, 0, 0))  # 红色
        else:
            display_text = "--"
            self.frag_sum_label.SetForegroundColour(wx.Colour(0, 100, 200))  # 蓝色
        
        self.frag_sum_label.SetLabel(display_text)
        
        # 更新指令数显示
        if instructions is not None:
            instructions_text = f"指令数:{instructions}"
            self.instructions_label.SetLabel(instructions_text)
            # 指令数显示为蓝色
            self.instructions_label.SetForegroundColour(wx.Colour(0, 100, 200))  # 蓝色
        else:
            self.instructions_label.SetLabel("")
    
    def calculate_longest_path_cycles_sum(self, output):
        """计算Longest Path Cycles三个值的和（与CompileResultDialog中的方法相同）"""
        try:
            # 查找"Longest Path Cycles:"在文本中的位置
            lines = output.split('\n')
            for line in lines:
                if "Longest Path Cycles:" in line:
                    # 提取冒号后面的部分
                    parts = line.split("Longest Path Cycles:")
                    if len(parts) > 1:
                        values_str = parts[1].strip()
                        
                        # 提取所有数字（可能用逗号、空格分隔，包括小数）
                        import re
                        # 匹配整数和小数，例如：1.7, 2, 0.5, 3.14
                        numbers = re.findall(r'\d+\.?\d*', values_str)
                        
                        if len(numbers) >= 3:
                            # 取前三个数字
                            try:
                                num1 = float(numbers[0])
                                num2 = float(numbers[1])
                                num3 = float(numbers[2])
                                return num1 + num2 + num3
                            except ValueError:
                                return None
            return None
        except Exception as e:
            print(f"计算Longest Path Cycles总和时出错: {e}")
            return None
    
    def extract_instructions_emitted(self, output):
        """提取Instructions Emitted字段的值"""
        try:
            # 查找"Instructions Emitted:"在文本中的位置
            lines = output.split('\n')
            for line in lines:
                if "Instructions Emitted:" in line:
                    # 提取冒号后面的部分
                    parts = line.split("Instructions Emitted:")
                    if len(parts) > 1:
                        values_str = parts[1].strip()
                        
                        # 提取第一个数字（可能用逗号、空格分隔）
                        import re
                        # 匹配整数，例如：12, 45, 100
                        numbers = re.findall(r'\d+', values_str)
                        
                        if numbers:
                            # 取第一个数字
                            try:
                                return int(numbers[0])
                            except ValueError:
                                return None
            return None
        except Exception as e:
            print(f"提取Instructions Emitted时出错: {e}")
            return None
    
    def on_key_press(self, event):
        """处理键盘事件：F1键显示帮助"""
        keycode = event.GetKeyCode()
        
        # F1键显示帮助
        if keycode == wx.WXK_F1:
            self.show_help()
            return
        
        # 其他按键继续正常处理
        event.Skip()
    
    def on_frag_char_hook(self, event):
        """处理frag列表键盘事件：回车键触发双击事件（使用CHAR_HOOK）"""
        keycode = event.GetKeyCode()
        
        # 检查是否是回车键（Enter键）
        if keycode == wx.WXK_RETURN or keycode == wx.WXK_NUMPAD_ENTER:
            # 阻止事件继续传播
            event.Skip(False)
            # 触发双击事件
            self.on_frag_double_click(event)
            return
        
        # 其他按键继续正常处理
        event.Skip()
    
    def on_frag_double_click(self, event):
        """处理frag列表双击事件：使用malisc.exe编译选中的frag文件"""
        selection = self.frag_list.GetSelection()
        if selection == wx.NOT_FOUND:
            wx.MessageBox("请先在右侧列表中选择一个.frag文件", "提示", wx.OK | wx.ICON_WARNING)
            return
        
        frag_file_name = self.frag_list.GetString(selection)
        current_path = self.path_combo.GetValue()
        if not current_path:
            wx.MessageBox("请先选择或输入路径", "提示", wx.OK | wx.ICON_WARNING)
            return
        
        # 构建frag文件的完整路径
        frags_dir = os.path.join(current_path, "Frags")
        frag_file_path = os.path.join(frags_dir, frag_file_name)
        
        if not os.path.exists(frag_file_path):
            wx.MessageBox(f"文件不存在: {frag_file_path}", "错误", wx.OK | wx.ICON_ERROR)
            return
        
        # 查找malisc.exe
        malisc_path = self.find_malisc_exe()
        if not malisc_path:
            wx.MessageBox(
                "未找到 malisc.exe\n"
                "请确保 Mali_Offline_Compiler_Windows 目录存在且包含 malisc.exe",
                "错误", wx.OK | wx.ICON_ERROR
            )
            return
        
        # 在新线程中执行编译，避免界面卡顿
        import threading
        thread = threading.Thread(
            target=self.compile_frag_in_thread,
            args=(frag_file_name, frag_file_path, malisc_path)
        )
        thread.daemon = True
        thread.start()
    
    def compile_frag_in_thread(self, frag_file_name, frag_file_path, malisc_path):
        """在新线程中编译frag文件并显示结果"""
        try:
            # 使用powershell执行malisc.exe
            cmd = f'powershell -Command "& \'{malisc_path}\' \'{frag_file_path}\'"'
            
            # 在主线程中更新状态栏
            wx.CallAfter(self.status_bar.SetStatusText, f"正在编译: {frag_file_name}")
            
            # 执行命令
            import subprocess
            result = subprocess.run(cmd, shell=True, capture_output=True, text=True, encoding='utf-8')
            
            # 显示结果
            output = result.stdout
            if result.returncode != 0:
                output += f"\n\n错误代码: {result.returncode}"
                if result.stderr:
                    output += f"\n错误信息: {result.stderr}"
            
            # 在主线程中创建和显示非模态对话框
            wx.CallAfter(self.show_compile_result, frag_file_name, output)
            
            # 在主线程中更新状态栏
            wx.CallAfter(self.status_bar.SetStatusText, f"编译完成: {frag_file_name}")
            
        except Exception as e:
            error_msg = f"编译失败: {str(e)}"
            wx.CallAfter(self.status_bar.SetStatusText, error_msg)
            wx.CallAfter(wx.MessageBox, error_msg, "错误", wx.OK | wx.ICON_ERROR)
    
    def show_help(self):
        """显示帮助对话框"""
        # 检查是否已经打开了帮助窗口
        if self.help_dialog is not None:
            try:
                # 尝试检查窗口是否仍然显示
                if self.help_dialog.IsShown():
                    # 如果帮助窗口已经打开，将其提到最前面
                    self.help_dialog.Raise()
                    return
            except RuntimeError:
                # 如果C++对象已被删除，清空引用
                self.help_dialog = None
        
        # 创建帮助对话框
        self.help_dialog = HelpDialog(self)
        # 绑定关闭事件，在对话框关闭时清空引用
        self.help_dialog.Bind(wx.EVT_CLOSE, self.on_help_close)
        self.help_dialog.Show()
    
    def on_help_close(self, event):
        """处理帮助窗口关闭事件"""
        # 清空帮助窗口引用
        self.help_dialog = None
        event.Skip()
    
    def show_compile_result(self, frag_file_name, output):
        """显示编译结果对话框（非模态）"""
        # 创建非模态对话框
        dlg = CompileResultDialog(self, frag_file_name, output)
        dlg.Show()
    
    def find_malisc_exe(self):
        """查找malisc.exe的路径"""
        # 可能的malisc.exe路径
        possible_paths = [
            # 在当前目录下的Mali_Offline_Compiler_Windows目录
            os.path.join(os.getcwd(), "Mali_Offline_Compiler_Windows", "malisc.exe"),
            # 在应用程序目录下的Mali_Offline_Compiler_Windows目录
            os.path.join(os.path.dirname(os.path.abspath(__file__)), "Mali_Offline_Compiler_Windows", "malisc.exe"),
            # 在系统PATH中
            "malisc.exe",
        ]
        
        for path in possible_paths:
            if os.path.exists(path):
                return os.path.abspath(path)
        
        return None
    
    def on_refresh(self, event):
        """处理刷新按钮点击事件：重新加载当前目录的文件"""
        current_path = self.path_combo.GetValue()
        if not current_path:
            wx.MessageBox("请先选择或输入路径", "提示", wx.OK | wx.ICON_WARNING)
            return
        
        if not os.path.isdir(current_path):
            wx.MessageBox(f"路径不是有效的目录: {current_path}", "错误", wx.OK | wx.ICON_ERROR)
            return
        self.frag_sum_label.SetLabel("--")
        self.instructions_label.SetLabel("--")
        try:
            self.status_bar.SetStatusText("正在刷新文件列表...")
            self.load_shader_files(current_path)
            self.status_bar.SetStatusText(f"刷新完成: {current_path}")
        except Exception as e:
            self.status_bar.SetStatusText(f"刷新失败: {str(e)}")
            wx.MessageBox(f"刷新失败: {str(e)}", "错误", wx.OK | wx.ICON_ERROR)
    
    def on_clear_history(self, event):
        """处理清空历史按钮点击事件"""
        # 确认对话框
        dlg = wx.MessageDialog(self, 
                              "确定要清空所有历史记录吗？\n此操作不可撤销。",
                              "确认清空历史",
                              wx.YES_NO | wx.NO_DEFAULT | wx.ICON_QUESTION)
        
        if dlg.ShowModal() == wx.ID_YES:
            try:
                # 读取现有配置
                config = {}
                if os.path.exists(self.CONFIG_FILE):
                    with open(self.CONFIG_FILE, 'r', encoding='utf-8') as f:
                        config = json.load(f)
                
                # 清空历史记录
                config["path_history"] = []
                # 保留last_path，以便用户仍然可以使用当前路径
                
                with open(self.CONFIG_FILE, 'w', encoding='utf-8') as f:
                    json.dump(config, f, indent=2, ensure_ascii=False)
                
                # 更新ComboBox的下拉列表
                self.path_combo.SetItems([])
                
                self.status_bar.SetStatusText("历史记录已清空")
                # wx.MessageBox("历史记录已成功清空", "完成", wx.OK | wx.ICON_INFORMATION)
            except Exception as e:
                self.status_bar.SetStatusText(f"清空历史记录失败: {str(e)}")
                wx.MessageBox(f"清空历史记录失败: {str(e)}", "错误", wx.OK | wx.ICON_ERROR)
        
        dlg.Destroy()
    
    def on_separate_frag(self, event):
        """处理分离frag按钮点击事件"""
        # 获取选中的shader文件
        selection = self.file_list.GetSelection()
        if selection == wx.NOT_FOUND:
            wx.MessageBox("请先在左侧列表中选择一个.shader文件", "提示", wx.OK | wx.ICON_WARNING)
            return
        
        file_name = self.file_list.GetString(selection)
        current_path = self.path_combo.GetValue()
        if not current_path:
            wx.MessageBox("请先选择或输入路径", "提示", wx.OK | wx.ICON_WARNING)
            return
        
        shader_path = os.path.join(current_path, file_name)
        
        try:
            # 分离frag
            frag_files = self.separate_frag_from_shader(shader_path, current_path)
            
            if frag_files:
                # 更新右侧frag列表
                self.load_frag_files(current_path)
                self.status_bar.SetStatusText(f"成功分离出 {len(frag_files)} 个frag文件")
                wx.MessageBox(f"成功分离出 {len(frag_files)} 个frag文件到 Frags 目录", "完成", wx.OK | wx.ICON_INFORMATION)
            else:
                self.status_bar.SetStatusText("未找到可分离的frag内容")
                wx.MessageBox("未在文件中找到 #ifdef FRAGMENT 标记，无法分离frag", "提示", wx.OK | wx.ICON_WARNING)
                
        except Exception as e:
            self.status_bar.SetStatusText(f"分离frag失败: {str(e)}")
            wx.MessageBox(f"分离frag失败: {str(e)}", "错误", wx.OK | wx.ICON_ERROR)
    
    def on_open_frag(self, event):
        """处理打开变体按钮点击事件：使用系统默认程序打开选中的frag文件"""
        # 获取选中的frag文件
        selection = self.frag_list.GetSelection()
        if selection == wx.NOT_FOUND:
            wx.MessageBox("请先在右侧列表中选择一个.frag文件", "提示", wx.OK | wx.ICON_WARNING)
            return
        
        frag_file_name = self.frag_list.GetString(selection)
        current_path = self.path_combo.GetValue()
        if not current_path:
            wx.MessageBox("请先选择或输入路径", "提示", wx.OK | wx.ICON_WARNING)
            return
        
        # 构建frag文件的完整路径
        frags_dir = os.path.join(current_path, "Frags")
        frag_file_path = os.path.join(frags_dir, frag_file_name)
        
        if not os.path.exists(frag_file_path):
            wx.MessageBox(f"文件不存在: {frag_file_path}", "错误", wx.OK | wx.ICON_ERROR)
            return
        
        try:
            # 使用系统默认程序打开文件
            if os.name == 'nt':  # Windows系统
                os.startfile(frag_file_path)
            elif os.name == 'posix':  # macOS或Linux系统
                import subprocess
                subprocess.run(['open', frag_file_path] if sys.platform == 'darwin' else ['xdg-open', frag_file_path])
            else:
                wx.MessageBox(f"不支持的操作系统: {os.name}", "错误", wx.OK | wx.ICON_ERROR)
                return
            
            self.status_bar.SetStatusText(f"已打开文件: {frag_file_name}")
            
        except Exception as e:
            self.status_bar.SetStatusText(f"打开文件失败: {str(e)}")
            wx.MessageBox(f"打开文件失败: {str(e)}", "错误", wx.OK | wx.ICON_ERROR)
    
    def separate_frag_from_shader(self, shader_path, base_directory):
        """从shader文件中分离frag内容"""
        if not os.path.exists(shader_path):
            raise FileNotFoundError(f"文件不存在: {shader_path}")
        
        # 读取文件内容
        with open(shader_path, 'r', encoding='utf-8') as f:
            lines = f.readlines()
        
        # 查找所有 #ifdef FRAGMENT 的位置
        fragment_indices = []
        for i, line in enumerate(lines):
            if '#ifdef FRAGMENT' in line:
                # 检查下一行是否包含 '#version X es'格式（X为数字）
                if i + 1 < len(lines):
                    next_line = lines[i + 1].strip()
                    # 使用正则表达式匹配 #version 数字 es 格式
                    import re
                    if re.search(r'#version\s+\d+\s+es', next_line):
                        fragment_indices.append(i)
        
        if len(fragment_indices) < 2:
            return []  # 至少需要两个 #ifdef FRAGMENT 才能分割
        
        # 创建Frags目录
        frags_dir = os.path.join(base_directory, "Frags")
        os.makedirs(frags_dir, exist_ok=True)
        
        # 获取shader文件名（不含扩展名）
        shader_name = os.path.splitext(os.path.basename(shader_path))[0]
        
        frag_files = []
        
        # 分割每个fragment块
        for i in range(len(fragment_indices) - 1):
            start_idx = fragment_indices[i]
            end_idx = fragment_indices[i + 1]
            
            # 提取fragment内容（从start_idx到end_idx-1）
            fragment_content = lines[start_idx:end_idx]
            
            # 处理文本：移除第一行的 #ifdef FRAGMENT 和最后的 #endif
            processed_content = self.process_fragment_content(fragment_content)
            
            # 生成文件名
            frag_filename = f"{shader_name}_{i+1:03d}.frag"
            frag_filepath = os.path.join(frags_dir, frag_filename)
            
            # 写入文件
            with open(frag_filepath, 'w', encoding='utf-8') as f:
                f.writelines(processed_content)
            
            frag_files.append(frag_filename)
        
        # 处理最后一个fragment块（到文件结尾）
        if fragment_indices:
            start_idx = fragment_indices[-1]
            fragment_content = lines[start_idx:]
            
            # 处理文本：移除第一行的 #ifdef FRAGMENT 和最后的 #endif
            processed_content = self.process_fragment_content(fragment_content)
            
            frag_filename = f"{shader_name}_{len(fragment_indices):03d}.frag"
            frag_filepath = os.path.join(frags_dir, frag_filename)
            
            with open(frag_filepath, 'w', encoding='utf-8') as f:
                f.writelines(processed_content)
            
            frag_files.append(frag_filename)
        
        return frag_files
    
    def process_fragment_content(self, content_lines):
        """处理fragment内容：移除标记、修改版本号并按分隔线分割"""
        if not content_lines:
            return []
        
        # 创建副本以避免修改原始列表
        processed = content_lines.copy()
        
        # 1. 移除第一行的 #ifdef FRAGMENT（如果存在）
        if processed and '#ifdef FRAGMENT' in processed[0]:
            processed = processed[1:]
        
        # 2. 查找分隔线 "//////////////////////////////////////////////////////"
        separator_line = "//////////////////////////////////////////////////////"
        separator_index = -1
        
        for i, line in enumerate(processed):
            if separator_line in line:
                separator_index = i
                break
        
        # 3. 如果找到分隔线，只保留分隔线之前的内容
        if separator_index != -1:
            processed = processed[:separator_index]
        
        # 4. 移除最后一行的 #endif（如果存在）及其后面的空行
        # 从后往前查找 #endif
        endif_index = -1
        for i in range(len(processed) - 1, -1, -1):
            if '#endif' in processed[i]:
                endif_index = i
                break
        
        if endif_index != -1:
            # 移除 #endif 行
            processed = processed[:endif_index]
            
            # 移除 #endif 后面的空行（从后往前移除连续的空行）
            while processed and processed[-1].strip() == '':
                processed = processed[:-1]
        
        # 5. 修改所有 #version X es 为 #version 320 es（X为任意数字）
        import re
        for i in range(len(processed)):
            # 使用正则表达式匹配 #version 数字 es 格式
            if re.search(r'#version\s+\d+\s+es', processed[i]):
                # 将版本号替换为320
                processed[i] = re.sub(r'#version\s+\d+\s+es', '#version 320 es', processed[i])
        
        return processed
    
    def load_frag_files(self, directory):
        """加载指定目录下Frags文件夹中的所有.frag文件"""
        self.frag_list.Clear()
        
        frags_dir = os.path.join(directory, "Frags")
        if not os.path.isdir(frags_dir):
            self.status_bar.SetStatusText(f"Frags目录不存在: {frags_dir}")
            return
        
        try:
            # 获取所有 .frag 文件
            frag_files = []
            for root, dirs, files in os.walk(frags_dir):
                for file in files:
                    if file.lower().endswith('.frag'):
                        full_path = os.path.join(root, file)
                        # 显示相对路径（相对于Frags目录）
                        rel_path = os.path.relpath(full_path, frags_dir)
                        frag_files.append(rel_path)
            
            if frag_files:
                frag_files.sort()  # 按字母顺序排序
                self.frag_list.Set(frag_files)
                self.status_bar.SetStatusText(f"找到 {len(frag_files)} 个.frag文件")
            else:
                self.status_bar.SetStatusText("未找到.frag文件")
                
        except Exception as e:
            self.status_bar.SetStatusText(f"加载frag文件失败: {str(e)}")
    
    def load_shader_files(self, directory):
        """加载指定目录中的所有 .shader 文件，并刷新frag列表"""
        self.file_list.Clear()
        
        # 保存路径到配置文件
        self.save_path_to_config(directory)
        
        if not os.path.isdir(directory):
            self.status_bar.SetStatusText(f"错误: {directory} 不是有效的目录")
            return
        
        try:
            # 获取所有 .shader 文件
            shader_files = []
            for root, dirs, files in os.walk(directory):
                for file in files:
                    if file.lower().endswith('.shader'):
                        full_path = os.path.join(root, file)
                        # 显示相对路径
                        rel_path = os.path.relpath(full_path, directory)
                        shader_files.append(rel_path)
            
            if shader_files:
                shader_files.sort()  # 按字母顺序排序
                self.file_list.Set(shader_files)
                self.status_bar.SetStatusText(f"找到 {len(shader_files)} 个 .shader 文件")
            else:
                self.status_bar.SetStatusText("未找到 .shader 文件")
            
            # 无论是否找到.shader文件，都尝试加载frag文件
            self.load_frag_files(directory)
                
        except Exception as e:
            self.status_bar.SetStatusText(f"错误: {str(e)}")


def main():
    app = wx.App(False)
    frame = ShaderBrowser(None, "Shader frag 分离器(YD)")  #创建应用程序的主窗口实例
    app.MainLoop()


if __name__ == '__main__':
    main()
